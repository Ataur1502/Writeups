<div align="center">

# Biased Stream

**Category:** Cryptography
**Difficulty:** Easy
**Author:** ZenRage
**Artifact:** `output.bin`, `cipherstreamer.py`

</div>

---

## Objective

Recover the hidden flag from a binary artifact generated by a flawed stream cipher.

The challenge is designed to test the solver’s ability to:

* recognize stream-cipher construction,
* identify bias and predictability in keystream generation,
* and exploit known-plaintext leakage to recover the internal state.

---

## Technical Solution

This walkthrough describes **one valid solution path**.
Alternative implementations may exist, but all correct solutions must converge on the same underlying cryptographic weakness.

---

## 1. Reconnaissance

### 1.1 Provided Files

```
cipherstreamer.py
output.bin
```

`cipherstreamer.py` prints a hexadecimal representation of `output.bin` and performs no decryption.

---

### 1.2 Initial Inspection

```bash
xxd output.bin
```

Example output:

```
00000000: a606 c9de ccd1 c8c3 cbd9 cfce f5d9 ded8  ................
00000010: cfcb c7f5 c6cf cbc1 cbcd cfd7            ............
```

Observations:

* No readable ASCII
* No headers or file signatures
* Appears to be raw ciphertext

This confirms that the flag is **not directly embedded**.

---

## 2. Stream Cipher Identification

From inspection of `cipherstreamer.py`, the following properties are evident:

* Encryption is byte-wise
* XOR is used
* A deterministic internal state is updated per byte

This strongly suggests a **stream cipher**.

---

## 3. Known-Plaintext Pivot

CTF flags follow a predictable format.
Here, the flag format is known to begin with:

```
bpctf{
```

This provides a **known plaintext prefix**, which is sufficient to recover early keystream bytes.

---

## 4. Keystream Recovery

### 4.1 Extract Ciphertext

```python
ct = open("output.bin","rb").read()
```

### 4.2 Recover Initial Keystream Bytes

The encryption equation is:

```
cipher[i] = plaintext[i] ^ keystream[i] ^ MASK
```

Where `MASK = 0xAA`.

Thus:

```
keystream[i] = cipher[i] ^ plaintext[i] ^ 0xAA
```

```python
crib = b"bpctf{"
ks = [ct[i] ^ crib[i] ^ 0xAA for i in range(len(crib))]
print(ks)
```

Example result:

```
Recovered keystream bytes: [110, 220, 0, 0, 0, 0]
```

This confirms:

* The keystream is **predictable**
* Early output contains strong bias (multiple zeros)

---

## 5. LFSR Identification

From `cipherstreamer.py`, the keystream generator matches an **8-bit LFSR** with feedback polynomial:

```
x⁸ + x⁷ + x⁵ + x⁴ + 1
```

Implemented as:

```python
def lfsr_step(s):
    return ((s << 1) ^ (0xB8 if s & 0x80 else 0)) & 0xFF
```

---

## 6. Initial State Recovery

The solver brute-forces all possible 8-bit initial states and checks which one reproduces the observed keystream prefix.

```python
def test_state(s0, observed):
    s = s0
    for o in observed:
        s = lfsr_step(s)
        if s != o:
            return False
    return True

for s0 in range(256):
    if test_state(s0, ks):
        print("Recovered initial state:", hex(s0))
        break
```

Result:

```
Recovered initial state: 0x37
```

---

## 7. Full Keystream Generation

With the initial state known, the entire keystream can be regenerated.

```python
state = 0x37
keystream = []

for _ in range(len(ct)):
    state = lfsr_step(state)
    keystream.append(state)
```

---

## 8. Decryption

Undo the encryption equation:

```
plaintext = cipher ^ keystream ^ MASK
```

```python
pt = bytes(ct[i] ^ keystream[i] ^ 0xAA for i in range(len(ct)))
print(pt)
```

Output:

```
b'bpctf{biased_stream_leakage}'
```

---

## 9. Final Flag

```
bpctf{biased_stream_leakage}
```

---

## 10. Vulnerability Summary

This challenge is broken due to **multiple compounding weaknesses**:

* Use of a **small (8-bit) LFSR**
* Deterministic keystream
* Known plaintext prefix
* Severe early-state bias (zero outputs)
* Linear XOR-based encryption

Even with an added masking constant, the cipher remains trivially breakable once the LFSR structure is recognized.

---

## Conclusion

The challenge demonstrates how **predictable keystream generation** undermines stream ciphers, even when obfuscation or masking is present. The correct approach is not brute force, but disciplined exploitation of structure, bias, and invariants.

This is a textbook example of **why stream ciphers must use cryptographically secure PRNGs and sufficiently large state spaces**.
